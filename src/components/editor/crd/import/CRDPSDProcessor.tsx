// Complete unified PSD layer interface for Cardshow platform
export interface CRDPSDLayer {
  id: string;
  name: string;
  type: 'text' | 'image' | 'shape' | 'group' | 'folder' | 'background' | 'adjustment';
  bounds: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  width: number;
  height: number;
  content?: {
    text?: string;
    fontSize?: number;
    fontFamily?: string;
    color?: string;
    imageData?: string;
  };
  styleProperties?: {
    opacity?: number;
    blendMode?: string;
    effects?: any[];
  };
  visible: boolean;
  opacity?: number;
  children?: CRDPSDLayer[];
  imageUrl?: string;
  textContent?: string;
  fontSize?: number;
  fontFamily?: string;
  color?: string;
  blendMode?: string;
  rawData?: any;
  isProcessed?: boolean;
}

// Export as PSDLayer for compatibility
export type PSDLayer = CRDPSDLayer;

export interface PSDProcessingResult {
  layers: PSDLayer[];
  totalLayers: number;
  processedLayers: number;
}

export interface GeneratedFrame {
  id: string;
  name: string;
  thumbnail: string;
  layers: PSDLayer[];
  metadata?: Record<string, any>;
  layerMapping?: Record<string, string>;
  autoGenerated?: boolean;
  frameConfig?: any;
}

// Import and re-export functions directly
import { readPsd } from 'ag-psd';

/**
 * Parse a PSD file and extract layer information
 */
export async function parsePSD(file: File): Promise<PSDProcessingResult> {
  try {
    // Read file as ArrayBuffer
    const arrayBuffer = await file.arrayBuffer();
    
    // Parse PSD using ag-psd
    const psdData = readPsd(arrayBuffer, {
      skipLayerImageData: false,
      skipCompositeImageData: true,
      skipThumbnail: true,
    });

    if (!psdData) {
      throw new Error('Failed to parse PSD file');
    }

    // Extract layers recursively
    const layers = extractLayers(psdData.children || [], psdData.width, psdData.height);
    
    return {
      layers,
      totalLayers: countTotalLayers(psdData.children || []),
      processedLayers: layers.length,
    };
  } catch (error) {
    console.error('Error parsing PSD:', error);
    throw new Error(`Failed to parse PSD: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Recursively extract layers from PSD data
 */
function extractLayers(layerData: any[], canvasWidth: number, canvasHeight: number, parentPath = ''): PSDLayer[] {
  const layers: PSDLayer[] = [];

  layerData.forEach((layer, index) => {
    const layerId = `layer_${parentPath}${index}`;
    const layerName = layer.name || `Layer ${index + 1}`;

    // Calculate bounds
    const left = layer.left || 0;
    const top = layer.top || 0;
    const right = layer.right || canvasWidth;
    const bottom = layer.bottom || canvasHeight;
    
    const bounds = {
      x: left,
      y: top,
      width: right - left,
      height: bottom - top,
    };

    const width = bounds.width;
    const height = bounds.height;

    // Determine layer type
    let layerType: PSDLayer['type'] = 'image';
    if (layer.text) {
      layerType = 'text';
    } else if (layer.children && layer.children.length > 0) {
      layerType = 'folder';
    } else if (layer.vectorMask || layer.vectorOrigination) {
      layerType = 'shape';
    } else if (layer.adjustment) {
      layerType = 'adjustment';
    }

    const psdLayer: PSDLayer = {
      id: layerId,
      name: layerName,
      type: layerType,
      visible: layer.hidden !== true,
      opacity: (layer.opacity || 255) / 255,
      blendMode: layer.blendMode || 'normal',
      bounds,
      width: Math.max(0, width),
      height: Math.max(0, height),
      rawData: layer,
      isProcessed: false,
    };

    // Extract text properties
    if (layerType === 'text' && layer.text) {
      psdLayer.textContent = layer.text.text || '';
      psdLayer.fontSize = layer.text.style?.fontSize || 12;
      psdLayer.fontFamily = layer.text.style?.fontName || 'Arial';
      
      // Extract color (simplified)
      if (layer.text.style?.fillColor) {
        const color = layer.text.style.fillColor;
        psdLayer.color = `rgb(${Math.round(color.r || 0)}, ${Math.round(color.g || 0)}, ${Math.round(color.b || 0)})`;
      }
    }

    // Process children for folder layers
    if (layerType === 'folder' && layer.children) {
      psdLayer.children = extractLayers(layer.children, canvasWidth, canvasHeight, `${layerId}_`);
    }

    layers.push(psdLayer);
  });

  return layers;
}

/**
 * Count total layers recursively
 */
function countTotalLayers(layerData: any[]): number {
  let count = 0;
  layerData.forEach(layer => {
    count++;
    if (layer.children) {
      count += countTotalLayers(layer.children);
    }
  });
  return count;
}

/**
 * Convert a layer to canvas image data
 */
export async function layerToImageData(layer: any, width: number, height: number): Promise<ImageData | null> {
  try {
    if (!layer.canvas) {
      return null;
    }

    // Create a temporary canvas to extract image data
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
      throw new Error('Failed to get canvas context');
    }

    // Draw the layer canvas
    ctx.drawImage(layer.canvas, 0, 0);
    
    return ctx.getImageData(0, 0, width, height);
  } catch (error) {
    console.error('Error converting layer to image data:', error);
    return null;
  }
}

/**
 * Convert layer to blob for upload
 */
export async function layerToBlob(layer: any, width: number, height: number, format: 'png' | 'jpg' = 'png'): Promise<Blob | null> {
  try {
    if (!layer.canvas) {
      return null;
    }

    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
      throw new Error('Failed to get canvas context');
    }

    // Clear canvas with transparency for PNG
    if (format === 'png') {
      ctx.clearRect(0, 0, width, height);
    } else {
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, width, height);
    }

    // Draw the layer
    ctx.drawImage(layer.canvas, 0, 0);

    return new Promise((resolve) => {
      canvas.toBlob(resolve, `image/${format}`, 0.9);
    });
  } catch (error) {
    console.error('Error converting layer to blob:', error);
    return null;
  }
}

// Legacy function name for compatibility  
export { parsePSD as processPSDFile };